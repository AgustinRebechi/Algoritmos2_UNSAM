# -*- coding: utf-8 -*-
"""introArboles.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10w2Mxsy9unZ7vAQh9I5sZm543DvNOeUK
"""

from collections.abc import Callable
from typing import Any, Generic, Optional, TypeVar
from functools import wraps  # Para decoradores

T = TypeVar('T')

# Clase que representa un Nodo del Árbol Binario
class NodoAB(Generic[T]):
    def __init__(self, dato: T, si: "Optional[ArbolBinario[T]]" = None, sd: "Optional[ArbolBinario[T]]" = None):
        """
        Constructor del nodo del árbol.
        dato: El valor que guarda el nodo
        si: Subárbol izquierdo (opcional)
        sd: Subárbol derecho (opcional)
        """
        self.dato = dato  # Guardamos el dato en el nodo
        # Si no nos dan subárbol izquierdo, creamos uno vacío
        self.si: ArbolBinario[T] = ArbolBinario() if si is None else si
        # Si no nos dan subárbol derecho, creamos uno vacío
        self.sd: ArbolBinario[T] = ArbolBinario() if sd is None else sd

    def __str__(self):
        """Método para convertir el nodo a string (para imprimir)"""
        return str(self.dato)  # Devolvemos el dato como string

# Clase principal que representa el Árbol Binario
class ArbolBinario(Generic[T]):
    def __init__(self):
        """Constructor del árbol binario. Al inicio está vacío."""
        self.raiz: Optional[NodoAB[T]] = None  # La raíz empieza como None (vacío)

    # Clase interna para decoradores (validaciones)
    class _Decoradores:
        @classmethod
        def valida_es_vacio(cls, f: Callable[..., Any]) -> Callable[..., Any]:
            """
            Decorador que verifica si el árbol está vacío antes de ejecutar una función.
            Si está vacío, lanza un error.
            """
            @wraps(f)
            def wrapper(self, *args: Any, **kwargs: Any) -> Any:
                if self.es_vacio():  # Si el árbol está vacío
                    raise TypeError('Arbol Vacio')  # Lanzamos error
                return f(self, *args, **kwargs)  # Si no, ejecutamos la función normal
            return wrapper

    # Método estático para crear un nuevo nodo
    @staticmethod
    def crear_nodo(dato: T, si: "Optional[ArbolBinario[T]]" = None, sd: "Optional[ArbolBinario[T]]" = None) -> "ArbolBinario[T]":
        """
        Crea un nuevo árbol con un nodo raíz que contiene 'dato'.
        si: Subárbol izquierdo (opcional)
        sd: Subárbol derecho (opcional)
        """
        t = ArbolBinario()  # Creamos árbol vacío
        t.raiz = NodoAB(dato, si, sd)  # Le ponemos un nodo raíz con el dato
        return t  # Devolvemos el nuevo árbol

    def es_vacio(self) -> bool:
          return self.raiz is None

    # Método para obtener el subárbol izquierdo (con validación de árbol vacío)
    @_Decoradores.valida_es_vacio
    def si(self) -> "ArbolBinario[T]":
        assert self.raiz is not None  # Aseguramos que no está vacío (por el decorador).
             #El assert es una afirmación que verifica que una condición sea verdadera.
              # Si es falsa, tira un error de tipo AssertionError
              #El decorador valida_es_vacio previene errores del usuario (como intentar acceder al hijo izquierdo de un árbol vacío).
              #El assert verifica condiciones internas: está para reforzar que el decorador hizo bien su trabajo.
              #Es una buena práctica en desarrollo y testing (lo vamos a ver en testing!)
        return self.raiz.si  # Devolvemos subárbol izquierdo

    # Método para obtener el subárbol derecho (con validación de árbol vacío)
    @_Decoradores.valida_es_vacio
    def sd(self) -> "ArbolBinario[T]":
        """Devuelve el subárbol derecho"""
        assert self.raiz is not None  # Aseguramos que no está vacío
        return self.raiz.sd  # Devolvemos subárbol derecho

    def es_hoja(self) -> bool:
        """
        Devuelve True si el nodo actual es una hoja (no tiene hijos).
        Una hoja es un nodo sin subárboles izquierdo ni derecho.
        """
        return not self.es_vacio() and self.si().es_vacio() and self.sd().es_vacio()

    # Método para obtener el dato de la raíz (con validación)
    @_Decoradores.valida_es_vacio
    def dato(self) -> T:
        """Devuelve el dato almacenado en la raíz del árbol"""
        assert self.raiz is not None  # Aseguramos que no está vacío.
        return self.raiz.dato  # Devolvemos el dato

    # Método para insertar un subárbol izquierdo
    @_Decoradores.valida_es_vacio
    def insertar_si(self, si: "ArbolBinario[T]"):
        """Inserta un nuevo subárbol izquierdo"""
        assert self.raiz is not None  # Aseguramos que no está vacío
        self.raiz.si = si  # Asignamos el nuevo subárbol izquierdo

    # Método para insertar un subárbol derecho (con validación)
    @_Decoradores.valida_es_vacio
    def insertar_sd(self, sd: "ArbolBinario[T]"):
        """Inserta un nuevo subárbol derecho"""
        assert self.raiz is not None  # Aseguramos que no está vacío
        self.raiz.sd = sd  # Asignamos el nuevo subárbol derecho

    def set_raiz(self, valor):
        """Establece un nuevo valor en la raíz del árbol"""
        self.raiz = NodoAB(valor)  # Crea un nuevo nodo con el valor y lo asigna como raíz

    def altura(self) -> int:
        """
        Calcula la altura del árbol (longitud del camino más largo desde la raíz hasta una hoja).
        Un árbol vacío tiene altura 0.
        """
        if self.es_vacio():  # Si el árbol está vacío
            return 0  # Altura 0
        else:
            # Altura = 1 (por el nodo actual) + la mayor altura de sus subárboles
            return 1 + max(self.si().altura(), self.sd().altura())

    def __len__(self) -> int:
        """
        Cuenta la cantidad de nodos en el árbol.
        Usa la función len() como en len(arbol).
        """
        if self.es_vacio():  # Si está vacío
            return 0  # No hay nodos
        else:
            # 1 (nodo actual) + nodos en subárbol izquierdo + nodos en subárbol derecho
            return 1 + len(self.si()) + len(self.sd())

    def __str__(self):
        """
        Representación visual del árbol con indentación para mostrar la estructura.
        Los nodos se muestran con puntos para indicar niveles.
        """
        def mostrar(t: ArbolBinario[T], nivel: int):
            tab = '.' * 4  # 4 puntos por nivel de indentación
            indent = tab * nivel  # Indentación según el nivel
            if t.es_vacio():  # Si el subárbol está vacío
                return indent + 'AV\n'  # Mostrar "AV" (Árbol Vacío)
            else:
                # Mostrar dato del nodo
                out = indent + str(t.dato()) + '\n'
                # Agregar subárbol izquierdo (nivel+1)
                out += mostrar(t.si(), nivel + 1)
                # Agregar subárbol derecho (nivel+1)
                out += mostrar(t.sd(), nivel + 1)
                return out

        return mostrar(self, 0)  # Comenzar desde nivel 0 (raíz)

    def inorder(self) -> list[T]:
        """
        Recorrido en orden (in-order): izquierda, raíz, derecha.
        Devuelve una lista con los datos en ese orden.
        """
        if self.es_vacio():  # Si está vacío
            return []  # Lista vacía
        else:
            # Subárbol izquierdo + raíz + subárbol derecho
            return self.si().inorder() + [self.dato()] + self.sd().inorder()

    def preorder(self) -> list[T]:
        pass

    def posorder(self) -> list[T]:
      pass

    def bfs(self) -> list[T]:
        pass

    def nivel(self, x: T) -> int:
        """
        Devuelve el nivel donde se encuentra el dato x.
        La raíz está en nivel 1. Si no está, devuelve altura+1.
        """
        pass

    def copy(self) -> "ArbolBinario[T]":
        """
        Crea una copia exacta del árbol.
        """
        pass

    def espejo(self) -> "ArbolBinario[T]":
        """
        Devuelve un nuevo árbol que es el espejo del original.
        Todos los subárboles izquierdos y derechos están intercambiados.
        """
        pass

    def sin_hojas(self) -> "ArbolBinario[T]":
        pass

# Función principal para probar el árbol
def main():
    # Creamos un árbol de ejemplo:
    #       1
    #     /   \
    #    2     3
    #   / \   / \
    #  4   5 6   7
    #     /
    #    8

    t = ArbolBinario.crear_nodo(1)  # Raíz con valor 1
    n2 = ArbolBinario.crear_nodo(2)  # Nodo 2
    n3 = ArbolBinario.crear_nodo(3)  # Nodo 3
    n4 = ArbolBinario.crear_nodo(4)  # Nodo 4
    n5 = ArbolBinario.crear_nodo(5)  # Nodo 5
    n6 = ArbolBinario.crear_nodo(6)  # Nodo 6
    n7 = ArbolBinario.crear_nodo(7)  # Nodo 7
    n8 = ArbolBinario.crear_nodo(8)  # Nodo 8

    # Construimos la estructura del árbol
    n2.insertar_si(n4)  # 2 tiene hijo izquierdo 4
    n2.insertar_sd(n5)  # 2 tiene hijo derecho 5
    n5.insertar_si(n8)  # 5 tiene hijo izquierdo 8
    n3.insertar_si(n6)  # 3 tiene hijo izquierdo 6
    n3.insertar_sd(n7)  # 3 tiene hijo derecho 7
    t.insertar_si(n2)   # 1 tiene hijo izquierdo 2
    t.insertar_sd(n3)   # 1 tiene hijo derecho 3

    # Mostramos el árbol
    print("Árbol original:")
    print(t)

    # Mostramos algunas propiedades
    print(f'Altura: {t.altura()}')  # Altura del árbol
    print(f'Nodos: {len(t)}')       # Cantidad de nodos

    # Recorrido por niveles (BFS)
    print(f'BFS: {t.bfs()}')

    # Copiamos el árbol
    t2 = t.copy()
    print("\nCopia del árbol:")
    print(t2)

    # Recorrido in-order
    print(f'Recorrido in-order: {t2.inorder()}')

    # Buscamos el nivel del número 8
    print(f'Nivel de 8: {t2.nivel(8)}')

    # Creamos el espejo del árbol
    t3 = t2.espejo()
    print("\nÁrbol espejo:")
    print(t3)

    # Árbol sin hojas
    print("\nÁrbol sin hojas:")
    print(t3.sin_hojas())

if __name__ == '__main__':
    main()